<!doctype html>
<html lang="en">
<head>

<title>Canvas Template</title>

<style>

  html, body {
    margin: 0;
    height: 100%;
    overflow: hidden;
  }

</style>

</head>
<body>

<canvas></canvas>


<script>(() => { 'use strict';

class Emitter {

  listeners = {};

  on(event, fn) {
    (this.listeners[event] ??= []).push(fn);
    return this;
  }

  off(event, fn) {
    const listeners = this.listeners[event];
    const i = listeners?.indexOf(fn) ?? -1;
    if (i >= 0) {
      listeners.splice(i, 1);
      if (!listeners.length) {
        delete this.listeners[event];
      }
    }
    return this;
  }

  emit(event, ...args) {
    for (const listener of this.listeners[event] ?? []) {
      listener?.apply?.(this, args);
    }
    return this;
  }

}

class Connection {

  connection = new Emitter;
  messages = new Emitter;

  constructor(host, connectionId = null, connectionKey = null) {
    this.host = host;
    this.connectionId = connectionId;
    this.connectionKey = connectionKey;
    this.reconnect();
  }

  reconnect() {
    const socket = this.socket = new WebSocket('ws://' + (this.host ?? 'localhost:8080'));
    socket.addEventListener('error', e => {
      console.error('ws error', e);
      this.connection.emit('error', e, this);
    });
    socket.addEventListener('close', () => {
      console.log('ws closed');
      this.connection.emit('close', this);
      // this.reconnect();
    });
    socket.addEventListener('open', () => {
      socket.send(JSON.stringify([ '$connect',
        ...(this.connectionId ? [ this.connectionId, this.connectionKey ] : [])
      ]));
    });
    socket.addEventListener('message', event => {
      let { data } = event;
      console.log('Message from server ', data);
      try {
        data = JSON.parse(data);
      } catch (e) {
        data = null;
      }
      if (!Array.isArray(data)) {
        console.error('Error parsing message');
        return;
      }
      const [ type, ...args ] = data;
      switch (type) {
        case '$connect': {
          this.connectionId = args[0];
          this.connectionKey = args[1];
          this.connection.emit('open', this);
        } break;
        default:
          this.messages.emit(type, ...args, this);
      }
    });
  }

  send(event, ...args) {
    if (this.socket.readyState === 1) {
      console.log();
      this.socket.send(JSON.stringify([ event, ...args ]));
    }
    return this;
  }

}

document.addEventListener('DOMContentLoaded', () => {

  const state = {
    tick: 0,
    colorful: false
  };

  const host = 'localhost:8080';
  const connection = new Connection(host);
  connection.messages
    .on('pos', (connectionId, x, y) => {
      if (connectionId === connection.connectionId) {
        return;
      }
      const pos = state.positions ??= {};
      if (!x && x !== 0) {
        delete pos[connectionId];
      } else {
        pos[connectionId] = [ x, y ];
      }
    })
  ;

  const canvas = document.querySelector('canvas');
  const ctx = canvas.getContext('2d');
  setInterval(function () {
    // ++state.tick;
  }, 100);
  window.addEventListener('keypress', e => {
    const keyCode = typeof e.which === "number" ? e.which : e.keyCode;
    onKeyPress(keyCode, state);
  });
  canvas.addEventListener('mousemove', e => {
    onMouseMove(e, state);
  });
  (function animationCallback() {
    // call again next time we can draw
    window.requestAnimationFrame(animationCallback);
    // Draw the thing
    animate(canvas, ctx, state, connection);
  })();
});

function onKeyPress(keyCode, state) {
  switch (keyCode) {
    case 32: // Spacebar
      state.colorful = !state.colorful;
      break;
    default:
      console.log(keyCode);
  }
}

function onMouseMove(event, state) {
  const { clientX, clientY } = event;
  state.mousePos = [ clientX, clientY ];
}

function animate(canvas, ctx, state, connection) {
  const width = canvas.width = window.innerWidth;
  const height = canvas.height = window.innerHeight;
  const halfWidth = width / 2;
  const halfHeight = height / 2;

  let [ mx, my ] = state.mousePos || [];
  mx ??= halfWidth;
  my ??= halfHeight;
  const x = Math.floor(mx - halfWidth);
  const y = Math.floor(my - halfHeight);
  if (state.pos?.[0] !== x || state.pos?.[1] !== y) {
    connection.send('pos', ...(state.pos = [ x, y ]));
  }
  ctx.beginPath();
  ctx.fillStyle = 'rgba(0, 0, 0, .5)';
  for (let [ connectionId, [ x, y ] ] of Object.entries(state.positions ?? {})) {
    drawPos(ctx, connectionId, x + halfWidth, y + halfHeight);
  }
  ctx.fill();
  ctx.fillStyle = 'rgba(64, 128, 255, .5)';
  drawPos(ctx, connection.connectionId, mx, my);
  ctx.fill();
}

const circle = 2 * Math.PI;
function drawPos(ctx, text, x, y) {
  ctx.arc(x, y, 4, 0, circle);
  ctx.fillText(text, x, y - 10);
}

})()</script>

</body>
</html>
